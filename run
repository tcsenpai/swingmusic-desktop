#!/bin/python
import os
import sys
import signal
import subprocess
import time
import psutil

BINARY_PATH = os.path.join(os.path.dirname(__file__), "swingmusic_bin/swingmusic")
print(BINARY_PATH)

# We need to find the swingmusic binary
if not (os.path.exists(BINARY_PATH)):
    print("[FATAL] Could not find swingmusic binary in path: " + BINARY_PATH)
    sys.exit(1)

print("[OK] Swingmusic binary found in path: " + BINARY_PATH)

# Running the binary and getting the pid
pid = subprocess.Popen([BINARY_PATH], stderr=subprocess.PIPE).pid
print(psutil.Process(pid))
print("[OK] Swingmusic started with pid: " + str(pid))

# Running yarn run .
os.system("yarn start .")

# Kill the binary process
os.kill(pid, signal.SIGINT)

# Ensure that the process is killed
max_kill_time = 15 # Seconds
kill_time = 0
while (kill_time < max_kill_time):
    if not psutil.pid_exists(pid):
        break
    # If the process is sleeping, is ok (it means that it is waiting for the next tick and then will die gracefully)
    process_status = psutil.Process(pid)
    if (process_status.status() == psutil.STATUS_SLEEPING):
        print("[WARNING] The subprocess is sleeping, but it is ok, it will die gracefully (maybe with some output)")
        break
    elif (process_status.status() == psutil.STATUS_ZOMBIE):
        print("[WARNING] The subprocess is a zombie, but it is ok, it will die gracefully ")
        break
    print("[WAITING] For process to stop... " + str(kill_time))
    kill_time += 1
    time.sleep(1)

if (kill_time >= max_kill_time):
    print("[ERROR] The subprocess looks stuck, please kill it manually with: kill -9 " + str(pid))
else:
    print("[OK] Swingmusic stopped (theoretically) with pid: " + str(pid))